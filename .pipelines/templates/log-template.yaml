# -- Captures --
# CNS, CNI, and Cilium Logs
# CNS, CNI, and Cilium State files
# Daemonset and Deployment Images
# Node Status
# kube-system namespace logs
# Non-ready pods on failure
# -- Controled by --
# CNI and OS | ${{ parameters.cni }} and ${{ parameters.os }}
# CNS ConfigMap | "ManageEndpointState"
# -- Generates --
# Logs on a per-node basis
# Outputs a singluar unique artifact per template call | ${{ parameters.clusterName }}_${{ parameters.jobName }}_Attempt_#$(System.StageAttempt)
# Each artifact is divided into sub-directories
# -- Intent --
# Provide through debugging information to understand why CNI test scenarios are failing without having to blindly reproduce

parameters:
  clusterName: ""
  logType: "failure"
  os: ""
  cni: ""
  jobName: "FailedE2ELogs"

steps:
  - task: AzureCLI@2
    inputs:
      azureSubscription: $(BUILD_VALIDATIONS_SERVICE_CONNECTION)
      scriptLocation: "inlineScript"
      scriptType: "bash"
      addSpnToEnvironment: true
      inlineScript: |
          make -C ./hack/aks set-kubeconf AZCLI=az CLUSTER=${{ parameters.clusterName }}

          acnLogs=$(System.DefaultWorkingDirectory)/${{ parameters.clusterName }}_${{ parameters.logType }}_Attempt_#$(System.StageAttempt)
          mkdir -p $acnLogs
          echo "Root Directory created: $acnLogs"
          echo "##vso[task.setvariable variable=acnLogs]$acnLogs"

          kubectl get pods -n kube-system -owide
          podList=`kubectl get pods -n kube-system --no-headers | awk '{print $1}'`
          mkdir -p $acnLogs/kube-system
          echo "Directory created: $acnLogs/kube-system"
          for pod in $podList; do
            kubectl logs -n kube-system $pod > $acnLogs/kube-system/$pod-logs.txt
            echo "$acnLogs/kube-system/$pod-logs.txt"
          done
    displayName: Kube-System Logs
    condition: always()
    continueOnError: true # Tends to fail after node restart due to pods still restarting. This should not block other tests or logs from running.

  - bash: |
      kubectl describe nodes
    displayName: Node Status
    condition: always()

  - bash: |
      kubectl get ds -A -owide
      echo "Capture daemonset images being used"
      dsList=`kubectl get ds -A | grep kube-system | awk '{print $2}'`
      for ds in $dsList; do
        echo "$ds"
        kubectl describe ds -n kube-system $ds | grep Image
      done
    displayName: Daemonset Images
    condition: always()

  - bash: |
      kubectl get deploy -A -owide
      echo "Capture deployment images being used"
      deployList=`kubectl get deploy -A | grep kube-system | awk '{print $2}'`
      for deploy in $deployList; do
        echo "$deploy"
        kubectl describe deploy -n kube-system $deploy | grep Image
      done
    displayName: Deployment Images
    condition: always()

  - ${{ if eq(parameters.logType, 'failure') }}:
    - bash: |
        kubectl get pods -n kube-system -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,NODE:.spec.nodeName
        podList=`kubectl get pods -n kube-system -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,NODE:.spec.nodeName --no-headers | grep -v Running | awk '{print $1}'`
        array=($podList)

        if [ -z ${array[0]} ]; then
          echo "There are no kube-system pods in a non-ready state."
        else
          mkdir -p $acnLogs/${{ parameters.os }}non-ready
          echo "Directory created: $acnLogs/${{ parameters.os }}non-ready"
          echo "Capturing failed pods"
          for pod in $podList; do
            kubectl describe pod -n kube-system $pod > $acnLogs/${{ parameters.os }}non-ready/$pod.txt
            echo "$acnLogs/${{ parameters.os }}non-ready/$pod.txt"
          done
        fi
      displayName: Failure Logs
      condition: always()

  - ${{ if eq(parameters.os, 'linux') }}:
    - script: |
        cd hack/scripts
        acnLogs=$(acnLogs) cni=${{ parameters.cni }} bash collect-linux-logs.sh
      displayName: Linux Logs
      condition: always()

  - ${{ if eq(parameters.os, 'windows') }}:
    - script: |
        cd hack/scripts
        acnLogs=$(acnLogs) cni=${{ parameters.cni }} bash collect-windows-logs.sh
      displayName: Windows Logs
      condition: always()

  - publish: $(System.DefaultWorkingDirectory)/${{ parameters.clusterName }}_${{ parameters.logType }}_Attempt_#$(System.StageAttempt)
    condition: always()
    artifact: ${{ parameters.clusterName }}_${{ parameters.logType }}_${{ parameters.os }}${{ parameters.jobName }}_Attempt_#$(System.StageAttempt)
    name: acnLogs_${{ parameters.logType }}
    displayName: Publish Cluster logs

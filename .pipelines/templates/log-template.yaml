# -- Captures --
# CNS, CNI, and Cilium Logs
# CNS, CNI, and Cilium State files
# Daemonset and Deployment Images
# kube-system namespace logs
# Non-ready pods on failure
# -- Controled by --
# CNI and OS | ${{ parameters.cni }} and ${{ parameters.os }}
# -- Generates --
# Logs on a per-node basis
# Outputs a singluar unique artifact per template call | ${{ parameters.clusterName }}_${{ parameters.logType }}_Attempt_#$(System.StageAttempt)
# -- Intent --
# Provide through debugging information to understand why CNI test scenarios are failing without having to blindly reproduce

parameters:
  clusterName: ""
  logType: "failure"
  os: ""
  cni: ""

steps:
  - task: AzureCLI@1
    inputs:
      azureSubscription: $(BUILD_VALIDATIONS_SERVICE_CONNECTION)
      scriptLocation: "inlineScript"
      scriptType: "bash"
      addSpnToEnvironment: true
      inlineScript: |
          set -e
          make -C ./hack/aks set-kubeconf AZCLI=az CLUSTER=${{ parameters.clusterName }}

          acnLogs=$(System.DefaultWorkingDirectory)/${{ parameters.clusterName }}_${{ parameters.logType }}_Attempt_#$(System.StageAttempt)
          mkdir -p $acnLogs
          echo Root Directory created: $acnLogs
          echo "##vso[task.setvariable variable=acnLogs]$acnLogs"

          kubectl get pods -n kube-system -owide
          podList=`kubectl get pods -n kube-system --no-headers | awk '{print $1}'`
          # capture all logs
          mkdir -p $acnLogs/kube-system
          echo Directory created: $acnLogs/kube-system
          for pod in $podList; do
            kubectl logs -n kube-system $pod > $acnLogs/kube-system/$pod-logs.txt
            echo $acnLogs/kube-system/$pod-logs.txt
          done
    displayName: Log Cluster
    condition: always()
    continueOnError: true # Tends to fail after node restart due to pods still restarting. This should not block other tests or logs from running.

  - bash: |
      kubectl get ds -A -owide
      echo Capture daemonset images being used
      dsList=`kubectl get ds -A | grep kube-system | awk '{print $2}'`
      for ds in $dsList; do
        echo $ds
        kubectl describe ds -n kube-system $ds | grep Image
      done
    displayName: Daemonset Images
    condition: always()

  - bash: |
      kubectl get deploy -A -owide
      echo Capture deployment images being used
      deployList=`kubectl get deploy -A | grep kube-system | awk '{print $2}'`
      for deploy in $deployList; do
        echo $deploy
        kubectl describe deploy -n kube-system $deploy | grep Image
      done
    displayName: Deployment Images
    condition: always()

  - ${{ if eq(parameters.os, 'linux') }}:
    - bash: |
        echo Ensure that privileged pod exists on each node
        kubectl apply -f test/integration/manifests/load/privileged-daemonset.yaml
        kubectl rollout status ds -n kube-system privileged-daemonset

        echo ------ Log work ------
        kubectl get pods -n kube-system -l os=linux -owide
        echo Capture logs from each linux node. Files located in var/logs
        podList=`kubectl get pods -n kube-system -l os=linux -owide | grep privileged | awk '{print $1}'`
        for pod in $podList; do
          output=`kubectl exec -i -n kube-system $pod -- ls /var/log/ | grep azure-`
          node=`kubectl get pod -n kube-system $pod -o custom-columns=NODE:.spec.nodeName,NAME:.metadata.name | grep privileged | awk '{print $1}'`
          for file in $output; do
            mkdir -p $(acnLogs)/"$node"_logs
            echo Directory created: $(acnLogs)/"$node"_logs/$file
            kubectl exec -i -n kube-system $pod -- cat /var/log/$file > $(acnLogs)/"$node"_logs/$file
            echo Azure-*.log, $file, captured: $(acnLogs)/"$node"_logs/$file
          done
        done

        # we can reuse the podlist var, must reassign output and node
        # azure-vnet is in both

        if ! [ ${{ parameters.cni }} = 'cilium' ]; then
          echo ------ Privileged work ------
          kubectl get pods -n kube-system -l os=linux -owide
          echo Capture State Files from privileged pods
          for pod in $podList; do
            node=`kubectl get pod -n kube-system $pod -o custom-columns=NODE:.spec.nodeName,NAME:.metadata.name | grep privileged | awk '{print $1}'`
            file="azure-vnet.json"
            kubectl exec -i -n kube-system $pod -- cat /var/run/$file > $(acnLogs)/"$node"_logs/$file
            echo CNI State, $file, captured: $(acnLogs)/"$node"_logs/$file
            if [ ${{ parameters.cni }} = 'cniv1' ]; then
              file="azure-vnet-ipam.json"
              kubectl exec -i -n kube-system $pod -- cat /var/run/$file > $(acnLogs)/"$node"_logs/$file
              echo CNI IPAM, $file, captured: $(acnLogs)/"$node"_logs/$file
            fi
          done
        fi

        if [ ${{ parameters.cni }} = 'cilium' ] || [ ${{ parameters.cni }} = 'cniv2' ]; then
          echo ------ CNS work ------
          kubectl get pods -n kube-system -l k8s-app=azure-cns --no-headers
          echo Capture State Files from CNS pods
          cnsPods=`kubectl get pods -n kube-system -l k8s-app=azure-cns --no-headers | awk '{print $1}'`
          for pod in $cnsPods; do
            file="cnsCache.txt"
            node=`kubectl get pod -n kube-system $pod -o custom-columns=NODE:.spec.nodeName,NAME:.metadata.name | grep cns | awk '{print $1}'`
            kubectl exec -i -n kube-system $pod -- curl localhost:10090/debug/ipaddresses -d {\"IPConfigStateFilter\":[\"Assigned\"]} > $(acnLogs)/"$node"_logs/$file
            echo CNS cache, $file, captured: $(acnLogs)/"$node"_logs/$file
            if [ ${{ parameters.cni }} = 'cilium' ]; then
              file="azure-endpoints.json"
              kubectl exec -i -n kube-system $pod -- cat /var/run/azure-cns/$file > $(acnLogs)/"$node"_logs/$file
              echo CNS Managed State, $file, captured: $(acnLogs)/"$node"_logs/$file
            fi
          done
        fi

        if [ ${{ parameters.cni }} = 'cilium' ]; then
          echo ------ Cilium work ------
          kubectl get pods -n kube-system -l k8s-app=cilium --no-headers
          echo Capture State Files from Cilium pods
          ciliumPods=`kubectl get pods -n kube-system -l k8s-app=cilium --no-headers | awk '{print $1}'`
          for pod in $ciliumPods; do
            file="cilium-endpoint.json"
            node=`kubectl get pod -n kube-system $pod -o custom-columns=NODE:.spec.nodeName,NAME:.metadata.name | grep cilium | awk '{print $1}'`
            kubectl exec -i -n kube-system $pod -- cilium endpoint list -o json > $(acnLogs)/"$node"_logs/$file
            echo Cilium, $file, captured: $(acnLogs)/"$node"_logs/$file
          done
        fi
      displayName: Linux Logs
      condition: always()

  - ${{ if eq(parameters.os, 'windows') }}:
    - bash: |
        echo Ensure that privileged pod exists on each node
        kubectl apply -f test/integration/manifests/load/privileged-daemonset-windows.yaml
        kubectl rollout status ds -n kube-system privileged-daemonset

        echo ------ Log work ------
        kubectl get pods -n kube-system -l os=windows -owide
        echo Capture logs from each windows node. Files located in c:\k
        podList=`kubectl get pods -n kube-system -l os=windows -owide | grep privileged | awk '{print $1}'`
        for pod in $podList; do
          output=`kubectl exec -i -n kube-system $pod -- powershell "ls ../../k/azure*.log*" | grep azure | awk '{print $6}'`
          node=`kubectl get pod -n kube-system $pod -o custom-columns=NODE:.spec.nodeName,NAME:.metadata.name | grep privileged | awk '{print $1}'`
          for file in $output; do
            mkdir -p $(acnLogs)/"$node"_logs
            echo Directory created: $(acnLogs)/"$node"_logs
            kubectl exec -i -n kube-system $pod -- powershell "cat ../../k/$file" > $(acnLogs)/"$node"_logs/$file
            echo Azure-*.log, $file, captured: $(acnLogs)/"$node"_logs/$file
          done
        done

        echo ------ privileged work ------
        kubectl get pods -n kube-system -l os=windows -owide
        echo Capture State Files from privileged pods
        for pod in $podList; do
          node=`kubectl get pod -n kube-system $pod -o custom-columns=NODE:.spec.nodeName,NAME:.metadata.name | grep privileged | awk '{print $1}'`
          file="azure-vnet.json"
          kubectl exec -i -n kube-system $pod -- powershell cat ../../k/$file > $(acnLogs)/"$node"_logs/$file
          echo CNI State, $file, captured: $(acnLogs)/"$node"_logs/$file
          if [ ${{ parameters.cni }} = 'cniv1' ]; then
            file="azure-vnet-ipam.json"
            kubectl exec -i -n kube-system $pod -- powershell cat ../../k/$file > $(acnLogs)/"$node"_logs/$file
            echo CNI IPAM, $file, captured: $(acnLogs)/"$node"_logs/$file
          fi
        done

        # This block needs to be exec cmd need to be verified
        if [ ${{ parameters.cni }} = 'cniv2' ]; then
          echo ------ CNS work ------
          kubectl get pods -n kube-system -l k8s-app=azure-cns-win --no-headers
          echo Capture State Files from CNS pods
          cnsPods=`kubectl get pods -n kube-system -l k8s-app=azure-cns-win --no-headers | awk '{print $1}'`
          for pod in $cnsPods; do
            file="cnsCache.txt"
            node=`kubectl get pod -n kube-system $pod -o custom-columns=NODE:.spec.nodeName,NAME:.metadata.name | grep cns | awk '{print $1}'`
            kubectl exec -i -n kube-system $pod -- powershell curl localhost:10090/debug/ipaddresses -d {\"IPConfigStateFilter\":[\"Assigned\"]} > $(acnLogs)/"$node"_logs/$file
            echo CNS cache, $file, captured: $(acnLogs)/"$node"_logs/$file
          done
        fi
      displayName: Windows Logs
      condition: always()

  - ${{ if eq(parameters.logType, 'failure') }}:
    - bash: |
        kubectl get pods -n kube-system -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,NODE:.spec.nodeName
        podList=`kubectl get pods -n kube-system -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,NODE:.spec.nodeName --no-headers | grep -v Running | awk '{print $1}'`
        array=($podList)

        if [ -z ${array[0]} ]; then
          echo There are no kube-system pods in a non-ready state.
        else
          mkdir -p $acnLogs/non-ready
          echo Directory created: $acnLogs/non-ready
          echo Capturing failed pods
          for pod in $podList; do
            kubectl describe pod -n kube-system $pod > $acnLogs/non-ready/$pod.txt
            echo $acnLogs/non-ready/$pod.txt
          done
        fi
      displayName: Failure Logs
      condition: always()

  - publish: $(System.DefaultWorkingDirectory)/${{ parameters.clusterName }}_${{ parameters.logType }}_Attempt_#$(System.StageAttempt)
    condition: always()
    artifact: ${{ parameters.clusterName }}_${{ parameters.logType }}_Attempt_#$(System.StageAttempt)
    name: acnLogs_${{ parameters.logType }}
    displayName: Publish Cluster logs

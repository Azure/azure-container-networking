stages:
- stage: unittest
  displayName: "Unit Tests"
  dependsOn:
  - setup
  variables:
    STORAGE_ID: $[ stagedependencies.setup.env.outputs['EnvironmentalVariables.StorageID'] ]
    ACN_DIR: azure-container-networking
  jobs:
  - job: linux
    displayName: "Run All"
    pool:
      type: linux
      isCustom: true
      name: "$(BUILD_POOL_NAME_DEFAULT)"
    variables:
      ob_outputDirectory: $(Build.ArtifactStagingDirectory)/linux-unittest

      REPORT_DIR: $(Build.ArtifactStagingDirectory)/linux-unittest
      REPORT_XML: $(Build.ArtifactStagingDirectory)/linux-unittest/report.xml
      COVERAGE_OUT: $(Build.ArtifactStagingDirectory)/linux-unittest/linux-coverage.out
    steps:
    - checkout: azure-container-networking

    - task: GoTool@0
      inputs:
        version: '$(GOVERSION)'

    - script: |
        set -e
        BIN_INSTALL_DIR=$(realpath bin)
        GOBIN="$BIN_INSTALL_DIR" go install github.com/jstemmer/go-junit-report/v2@latest
        JUNIT_REPORT_BIN="$BIN_INSTALL_DIR/go-junit-report"

        mkdir -p "$REPORT_DIR"
        touch "$REPORT_XML"
        make tools

        # run test, echo exit status code to fd 3, pipe output from test to tee, which splits output to stdout and go-junit-report (which converts test output to report.xml),
        # stdout from tee is redirected to fd 4. Take output written to fd 3 (which is the exit code of test), redirect to stdout, pipe to read from stdout then exit with that status code.
        # Read all output from fd 4 (output from tee) and write to to stdout
        { { { {
              sudo -E env "PATH=$PATH" make test-all;
              echo $? >&3;
              } | tee >($JUNIT_REPORT_BIN > "$REPORT_XML") >&4;
            } 3>&1;
          } | { read xs; exit $xs; }
        } 4>&1

        ls -la "$REPORT_DIR"
        mv coverage-all.out "$COVERAGE_OUT"
        ls -la "$REPORT_DIR"
      retryCountOnTaskFailure: 3
      displayName: "Run Unit Tests - Linux"
      #workingDirectory: $(ACN_DIR)

    - script: |
        BIN_INSTALL_DIR=$(realpath bin)
        GOBIN="$BIN_INSTALL_DIR" go install github.com/axw/gocov/gocov@latest
        GOBIN="$BIN_INSTALL_DIR" go install github.com/AlekSi/gocov-xml@latest

        GOCOV_BIN="$BIN_INSTALL_DIR/gocov"
        GOCOV_XML_BIN="$BIN_INSTALL_DIR/gocov-xml"

        $GOCOV_BIN convert "$COVERAGE_OUT" > "$REPORT_DIR"/linux-coverage.json
        $GOCOV_XML_BIN < "$REPORT_DIR"/linux-coverage.json > "$REPORT_DIR"/linux-coverage.gocov.xml

        echo "##vso[task.setvariable variable=COVERAGE_OUT_XML;isOutput=true]$(cat $REPORT_DIR/linux-coverage.xml)"
        echo "##vso[task.setvariable variable=GOCOV_OUT_XML;isOutput=true]$(cat $REPORT_DIR/linux-coverage.gocov.xml)"
      name: report
      displayName: "Generate Test Reporting"


  - job: windows
    displayName: "Run Tests - Windows"
    pool:
      isCustom: true
      type: windows
      name: "$(BUILD_POOL_NAME_DEFAULT_WINDOWS_ALT)"
    variables:
      ob_outputDirectory: $(Build.ArtifactStagingDirectory)/windows-unittest

      REPORT_DIR: $(Build.ArtifactStagingDirectory)/windows-unittest
      REPORT_XML: report.xml
      GOCOV_OUT: windows-gocov.out
      COVERAGE_OUT: windows-coverage.out
    steps:
    - checkout: azure-container-networking

    - task: GoTool@0
      inputs:
        version: '$(GOVERSION)'

    - shell: |
        which gcc
        echo "##vso[task.setvariable variable=CGO_PATH;]$(dirname $(which gcc))"

    - task: UsePythonVersion@0
      inputs:
        versionSpec: '3.x' # string. Required. Version spec. Default: 3.x.
        addToPath: true

    - task: PythonScript@0
      displayName: "Run Unit Tests - Windows"
      retryCountOnTaskFailure: 3
      inputs:
        scriptSource: 'inline'
        arguments: $(Build.SourcesDirectory) $(CGO_PATH)
        script: |
          import os
          import subprocess
          import sys
          
          # Set environment variables and directories
          cwd = sys.argv[1]
          cwd = os.path.realpath(cwd)
          bin_install_dir = os.path.join(cwd, 'bin')
          os.environ['GOBIN'] = bin_install_dir

          cgo_path = sys.argv[2]
          os.environ['PATH'] += ':{cgo_path}'
          
          report_dir = os.environ['REPORT_DIR']
          report_dir = os.path.realpath(report_dir)
          
          coverage_file = os.environ['COVERAGE_OUT']
          coverage_out = os.path.join(report_dir, coverage_file)
          
          gocover_file = os.environ['GOCOV_OUT']
          gocover_out = os.path.join(report_dir, gocover_file)
          
          junit_file = os.environ['REPORT_XML']
          junit_xml = os.path.join(report_dir, junit_file)
          
          # Install the go-junit-report tool
          subprocess.check_call(['go', 'install', 'github.com/jstemmer/go-junit-report/v2@latest'])
          junit_report_bin = os.path.join(bin_install_dir, 'go-junit-report')
          
          # Create report directory and touch report XML file
          os.makedirs(report_dir, exist_ok=True)
          
          # Run make tools
          subprocess.run('make tools', shell=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
          
          # Function to run the test and capture output
          def run_test():
              os.environ['CGO_ENABLED'] = "1"
              cmd_gotest = 'go test -timeout 30m -mod=readonly -buildvcs=false -tags "unit" '
              cmd_gotest += f"--skip 'TestE2E*' -race -covermode atomic -coverprofile={coverage_out} ./npm/... ./cni/... ./platform/..."
              cmd_junitreport = f'{junit_report_bin} -set-exit-code -in {report_dir}/test.log -out {junit_xml} -iocopy'
              cmd_gocover = f'go tool cover -func={coverage_out}'
          
              print(cmd_gotest)
              gotest_process = subprocess.run(cmd_gotest, shell=True, stdout=open(f'{report_dir}/test.log', 'w'), text=True, cwd=cwd)
          
              print(cmd_junitreport)
              junit_process = subprocess.run(cmd_junitreport, shell=True, stdout=sys.stdout, stderr=sys.stderr, text=True, cwd=cwd)
          
              print(cmd_gocover)
              gocover_process = subprocess.run(cmd_gocover, shell=True, text=True, stdout=open(gocover_out, "w"), cwd=cwd)
          
              test_exit_code = gotest_process.returncode
              sys.exit(test_exit_code)
          
          # Run the test function
          run_test()

          # List report directory contents again
          print(os.listdir(report_dir))
        
    - task: PythonScript@0
      displayName: "Generate Test Reporting"
      name: report
      inputs:
        arguments: $(Build.SourcesDirectory)
        scriptSource: 'inline'
        script: |
          import os
          import subprocess
          
          # Define the necessary variables
          cwd = sys.argv[1]
          cwd = os.path.realpath(cwd)
          bin_install_dir = os.path.join(cwd, 'bin')
          os.environ['GOBIN'] = bin_install_dir
          
          report_dir = os.environ['REPORT_DIR']
          report_dir = os.path.realpath(report_dir)
          
          coverage_file = os.environ['COVERAGE_OUT']
          coverage_out = os.path.join(report_dir, coverage_file)
          coverage_json = os.path.join(report_dir, 'windows-coverage.json')
          coverage_xml = os.path.join(report_dir, 'windows-coverage.xml')
          
          gocover_file = os.environ['GOCOV_OUT']
          gocover_out = os.path.join(report_dir, gocover_file)
          
          junit_file = os.environ['REPORT_XML']
          junit_xml = os.path.join(report_dir, junit_file)
          
          # Set the GOBIN environment variable
          os.environ['GOBIN'] = BIN_INSTALL_DIR
          
          # Install gocov and gocov-xml
          subprocess.run(['go', 'install', 'github.com/axw/gocov/gocov@latest'], check=True)
          subprocess.run(['go', 'install', 'github.com/AlekSi/gocov-xml@latest'], check=True)
          
          # Define the paths to the installed binaries
          GOCOV_BIN = os.path.join(bin_install_dir, 'gocov')
          GOCOV_XML_BIN = os.path.join(bin_install_dir, 'gocov-xml')
          
          # Create the report directory if it doesn't exist
          os.makedirs(report_dir, exist_ok=True)
          
          # Convert coverage output to JSON
          with open(coverage_json, 'w') as json_file:
            subprocess.run([gocov_bin, 'convert', coverage_out], stdout=json_file, check=True)
          
          # create coverage xml
          with open(coverage_xml, 'w') as xml_file:
              with open(coverage_json, 'r') as json_file:
                  subprocess.run([gocov_xml_bin], stdin=json_file, stdout=xml_file, check=True)
          # coverage json
          with open(coverage_json, 'r') as f:
            coverage_out_json_content = f.read()
            print(f"##vso[task.setvariable variable=COVERAGE_OUT_JSON;isOutput=true]{coverage_out_json_content}")
          # coverage xml
          with open(coverage_xml, 'r') as xml_file:
            xml_content = xml_file.read()
            print(f"##vso[task.setvariable variable=COVERAGE_OUT_XML;isOutput=true]{xml_content}")
          # go cover 
          with open(gocover_out, 'r') as f:
            gocover_out_content = f.read()
            print(f"##vso[task.setvariable variable=GOCOV_OUT;isOutput=true]{gocover_out_content}")
          # junit xml
          with open(junit_xml, 'r') as f:
            junit_xml_content = f.read()
            print(f"##vso[task.setvariable variable=JUNIT_XML;isOutput=true]{junit_xml_content}")


  - job: coverage
    displayName: "Check Test Coverage"
    condition: always()
    dependsOn:
    - windows
    - linux
    pool:
      type: linux
    variables:
      ob_outputDirectory: $(Build.ArtifactStagingDirectory)/out

      WINDOWS_JUNIT_XML: $[ dependencies.windows.outputs['report.JUNIT_XML'] ]
      WINDOWS_COVERAGE_OUT: $[ dependencies.windows.outputs['report.COVERAGE_OUT_XML'] ]
      WINDOWS_GOCOV_OUT: $[ dependencies.windows.outputs['report.GOCOV_OUT'] ]
      LINUX_COVERAGE_OUT: $[ dependencies.linux.outputs['report.COVERAGE_OUT_XML'] ]
      LINUX_GOCOV_OUT: $[ dependencies.linux.outputs['report.GOCOV_OUT_XML'] ]
    steps:
    - script: |
        mkdir "$COV_DIR"
        echo "$LINUX_COVERAGE_OUT" > "$COV_DIR"/linux-coverage.xml
        echo "$LINUX_GOCOV_OUT" > "$COV_DIR"/linux-coverage.gocov.xml
        echo "$WINDOWS_COVERAGE_OUT" > "$COV_DIR"/windows-coverage.xml
        echo "$WINDOWS_GOCOV_OUT" > "$COV_DIR"/windows-coverage.gocov.xml
        echo "$WINDOWS_JUNIT_XML" > "$COV_DIR"/windows-coverage.junit.xml
      env:
        COV_DIR: $(Build.ArtifactStagingDirectory)/coverage

    - task: PublishTestResults@2
      displayName: "Publish Test Results"
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles:  # string. Required. Test results files. Default: **/TEST-*.xml.
        searchFolder: coverage/**/*.xml
        failTaskOnFailedTests: true
        failTaskOnMissingResultsFile: false
        #testRunTitle: # Name of the test runs
        # boolean. Merge test results. Default: false.
        mergeTestResults: true
        #failTaskOnFailureToPublishResults: false # boolean. Fail if there is failure in publishing test results. Default: false.
      # Advanced
        #buildPlatform: windows/amd64
        #buildConfiguration: # string. Alias: configuration. Build Configuration.
        publishRunAttachments: true

    - task: PublishCodeCoverageResults@2
      displayName: "Publish Code Coverage Report"
      inputs:
        summaryFileLocation: coverage/*

    - task: BuildQualityChecks@8
      displayName: "Check Code Coverage Regression"
      inputs:
        checkCoverage: true
        coverageFailOption: "build"
        coverageType: "lines"
        fallbackOnPRTargetBranch: false
        baseBranchRef: "master"
        allowCoverageVariance: true
        coverageVariance: 0.25

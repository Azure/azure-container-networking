Controller-runtime abstracts listwatchers, informers, workqueues
    - Under the hood it's really just this sample controller https://github.com/kubernetes/sample-controller in an opinionated way


KubeBuilder is a CLI that helps generate code to make CRDs and the code it generates uses controller-runtime
 
Alot of Matt's code was generated by KubeBuilder

I'm not reconciling objects, I'm just watching for status changes (which is technically still reconciling: https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg#hdr-Controller)

Does KubeBuilder notify on status changes too, not just spec changes?

Controller-runtime is less boilerplate code

I'm just watching the status, not requeueing events

the main benefit of controller-runtime (besides the code scaffolding) is that it allows you to fail and try again without having to do anything. 
If your function returns an error, it just calls it again later. 
That's beneficial to me because I need to make HTTP calls to DNC, and if those fail, I need to try again later. 
But for you, you should just be updating a local file with your new IP allocations, which you can just block/retry until you succeed.

I only have one process per node

well you have one process per node, so if that process fails to write the file for that node, you'll just try again. 
So blocking and retrying is essentially the same as exiting a goroutine, spawning a new goroutine, and trying again. 
For me, I'll have a fixed number of goroutines for the whole cluster. Say it's 10 goroutines, and say DNC is really acting up. 
Theoretically, I would be in a world of pain if I had 10 goroutines just blocking for 10 different Nodes, since I wouldn't be able to do any other work

/var/lib/kubelet/kubeconfig